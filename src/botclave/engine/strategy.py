"""
Strategy module that combines SMC indicators with Orderflow data to generate ENTRY/EXIT signals.

This module implements the core trading strategy logic that analyzes market structure
(Smart Money Concepts) and order flow patterns to identify high-probability trading
opportunities with proper risk-reward ratios.
"""

from dataclasses import dataclass
from typing import List, Optional, Dict
import pandas as pd
import numpy as np
from botclave.engine.indicators import SMCIndicator
from botclave.engine.footprint import KlineFootprint


# ============================================================================
# 1. SIGNAL DATACLASSES
# ============================================================================

@dataclass
class RiskRewardSetup:
    """Risk/Reward configuration for a trade"""
    entry_price: float
    stop_loss_price: float
    take_profit_price: float
    position_size: float         # As % of capital
    
    @property
    def risk_amount(self) -> float:
        """Risk amount in monetary terms"""
        return abs(self.entry_price - self.stop_loss_price) * self.position_size
    
    @property
    def reward_amount(self) -> float:
        """Potential profit amount"""
        return abs(self.take_profit_price - self.entry_price) * self.position_size
    
    @property
    def risk_reward_ratio(self) -> float:
        """RR = reward / risk"""
        if self.risk_amount == 0:
            return 0.0
        return self.reward_amount / self.risk_amount
    
    def is_valid_rr(self, min_rr: float = 3.0) -> bool:
        """Validate that RR is >= min_rr"""
        return self.risk_reward_ratio >= min_rr


@dataclass
class Signal:
    """Trading signal generated by the strategy"""
    signal_type: str                # 'ENTRY_LONG', 'ENTRY_SHORT', 'EXIT_LONG', 'EXIT_SHORT'
    index: int                      # Index in the DataFrame
    price: float                    # Current price
    time: str                       # Timestamp
    confidence: float               # 0-1, signal strength
    
    # Signal components
    smc_component: str              # 'BOS', 'FFG', 'OB', etc
    orderflow_component: str        # 'ABSORPTION_BUY', 'ABSORPTION_SELL', 'IMBALANCE'
    
    # Setup if it's an entry
    entry_setup: Optional[RiskRewardSetup] = None
    
    # Justification
    reason: str = ""


# ============================================================================
# 2. SESSION FILTER (Market Session Detection)
# ============================================================================

class SessionFilter:
    """Filters signals by active market sessions (SMC-repo adapted for crypto).
    
    Detects if current time falls within major trading sessions:
    - London: 3:00-12:00 UTC (high liquidity)
    - New York: 13:00-22:00 UTC (high liquidity) 
    - Asian Kill Zone: 0:00-4:00 UTC (Tokyo open momentum)
    
    Usage:
        session_filter = SessionFilter(['London', 'New York', 'Asian Kill Zone'])
        if session_filter.is_active_session(df):
            # Generate signal
    """
    
    def __init__(self, active_sessions: List[str] = None):
        """Initialize with list of active sessions.
        
        Args:
            active_sessions: List of session names to consider active.
                          Options: 'London', 'New York', 'Asian Kill Zone'
        """
        if active_sessions is None:
            active_sessions = ['London', 'New York', 'Asian Kill Zone']
        
        self.active_sessions = active_sessions
        
        # Session time ranges in UTC (hour: 0-23)
        self.session_hours = {
            'London': (3, 12),  # 03:00-12:00 UTC
            'New York': (13, 22),  # 13:00-22:00 UTC  
            'Asian Kill Zone': (0, 4),  # 00:00-04:00 UTC
            'Tokyo': (0, 9),  # 00:00-09:00 UTC (full Asian session)
            'Sydney': (22, 7),  # 22:00-07:00 UTC (wraps around midnight)
        }
    
    def is_active_session(self, df: pd.DataFrame) -> bool:
        """Check if current candle falls within active sessions.
        
        Args:
            df: DataFrame with datetime index
            
        Returns:
            True if current time is in an active session
        """
        if df.empty or not hasattr(df.index, 'time'):
            return False
            
        # Get current hour in UTC
        current_time = df.index[-1]
        if hasattr(current_time, 'tz_localize'):
            # Convert to UTC if timezone aware
            if current_time.tz is not None:
                current_time = current_time.tz_convert('UTC')
            else:
                current_time = current_time.tz_localize('UTC')
        
        current_hour = current_time.hour
        
        # Check each active session
        for session in self.active_sessions:
            if session in self.session_hours:
                start, end = self.session_hours[session]
                
                # Handle sessions that wrap around midnight (like Sydney)
                if start <= end:
                    if start <= current_hour < end:
                        return True
                else:
                    # Session wraps around midnight (e.g., 22:00-07:00)
                    if current_hour >= start or current_hour < end:
                        return True
        
        return False
    
    def get_current_session(self, df: pd.DataFrame) -> str:
        """Get name of current session.
        
        Args:
            df: DataFrame with datetime index
            
        Returns:
            Current session name or 'Outside Session'
        """
        if df.empty or not hasattr(df.index, 'time'):
            return 'Outside Session'
            
        current_time = df.index[-1]
        if hasattr(current_time, 'tz_localize'):
            if current_time.tz is not None:
                current_time = current_time.tz_convert('UTC')
            else:
                current_time = current_time.tz_localize('UTC')
                
        current_hour = current_time.hour
        
        for session, (start, end) in self.session_hours.items():
            # Handle sessions that wrap around midnight
            if start <= end:
                if start <= current_hour < end:
                    return session
            else:
                if current_hour >= start or current_hour < end:
                    return session
        
        return 'Outside Session'


# ============================================================================
# 3. ATR CALCULATOR (Dynamic Risk Management)
# ============================================================================

class ATRCalculator:
    """Calculates Average True Range for dynamic SL/TP sizing.
    
    Uses ATR to calculate risk-based stop losses and take profits:
    - SL = Entry ¬± (2 √ó ATR) 
    - TP = Entry ¬± (3 √ó ATR) for 1.5:1 minimum RR
    - TP = Entry ¬± (4 √ó ATR) for 2:1 RR
    
    Usage:
        atr_calc = ATRCalculator(period=14)
        atr = atr_calc.calculate(df).iloc[-1]
        sl = atr_calc.get_sl_price(entry_price, atr, 'long')
        tp = atr_calc.get_tp_price(entry_price, atr, 'long', rr_ratio=2.0)
    """
    
    def __init__(self, period: int = 14):
        """Initialize ATR calculator.
        
        Args:
            period: ATR calculation period (default: 14)
        """
        self.period = period
    
    def calculate(self, df: pd.DataFrame) -> pd.Series:
        """Calculate ATR series.
        
        Args:
            df: DataFrame with OHLC columns
            
        Returns:
            ATR series
        """
        if len(df) < self.period:
            return pd.Series([0.0] * len(df), index=df.index)
        
        # Calculate true range
        high = df['high']
        low = df['low']
        close = df['close']
        
        tr1 = high - low
        tr2 = abs(high - close.shift(1))
        tr3 = abs(low - close.shift(1))
        
        true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        
        # Calculate ATR using exponential moving average (Wilder's method)
        atr = true_range.ewm(alpha=1/self.period, min_periods=self.period).mean()
        
        return atr
    
    def get_sl_price(self, entry_price: float, atr: float, 
                     direction: str, multiplier: float = 2.0) -> float:
        """Calculate stop loss price based on ATR.
        
        Args:
            entry_price: Trade entry price
            atr: Current ATR value
            direction: 'long' or 'short'
            multiplier: ATR multiplier (default: 2.0)
            
        Returns:
            Stop loss price
        """
        if direction == 'long':
            return entry_price - (atr * multiplier)
        elif direction == 'short':
            return entry_price + (atr * multiplier)
        else:
            raise ValueError("Direction must be 'long' or 'short'")
    
    def get_tp_price(self, entry_price: float, atr: float,
                     direction: str, rr_ratio: float = 2.0) -> float:
        """Calculate take profit price based on risk/reward ratio.
        
        Args:
            entry_price: Trade entry price
            atr: Current ATR value
            direction: 'long' or 'short'
            rr_ratio: Risk/reward ratio (default: 2.0 = 2:1)
            
        Returns:
            Take profit price
        """
        risk_distance = atr * 2.0  # SL distance
        reward_distance = risk_distance * rr_ratio
        
        if direction == 'long':
            return entry_price + reward_distance
        elif direction == 'short':
            return entry_price - reward_distance
        else:
            raise ValueError("Direction must be 'long' or 'short'")
    
    def get_rr_setup(self, entry_price: float, atr: float,
                    direction: str, rr_ratio: float = 2.0,
                    atr_multiplier: float = 2.0) -> RiskRewardSetup:
        """Create complete RiskRewardSetup based on ATR.
        
        Args:
            entry_price: Trade entry price
            atr: Current ATR value
            direction: 'long' or 'short'  
            rr_ratio: Risk/reward ratio (default: 2.0)
            atr_multiplier: ATR multiplier for SL (default: 2.0)
            
        Returns:
            RiskRewardSetup with SL/TP calculated from ATR
        """
        sl_price = self.get_sl_price(entry_price, atr, direction, atr_multiplier)
        tp_price = self.get_tp_price(entry_price, atr, direction, rr_ratio)
        
        return RiskRewardSetup(
            entry_price=entry_price,
            stop_loss_price=sl_price,
            take_profit_price=tp_price,
            position_size=1.0
        )


# ============================================================================
# 4. ORDERFLOW ANALYZER (Absorption Detection)
# ============================================================================

class OrderflowAnalyzer:
    """Analyzes orderflow/absorption in the footprint to detect smart money activity"""
    
    def __init__(self, delta_threshold: float = 0.65, 
                 volume_threshold: float = 100000):
        """
        Args:
            delta_threshold: % of delta (buy-sell) to consider absorption
            volume_threshold: minimum volume in USD to detect absorption
        """
        self.delta_threshold = delta_threshold
        self.volume_threshold = volume_threshold
    
    def detect_absorption(self, footprint: KlineFootprint, 
                         price_level: float, 
                         current_price: float) -> Optional[str]:
        """
        Detects absorption at a specific price level
        
        BUY absorption:
        - buy_qty >> sell_qty at that level
        - delta > 65% positive
        - Price didn't rise = smart money buying
        
        SELL absorption:
        - sell_qty >> buy_qty at that level
        - delta > 65% negative
        - Price didn't fall = smart money selling
        
        Args:
            footprint: KlineFootprint with trade data
            price_level: Price level to check for absorption
            current_price: Current price
        
        Returns:
            'BUY' (buy absorption), 'SELL' (sell absorption), or None
        """
        # Get imbalance at this price level
        imbalance = footprint.get_imbalance(price_level, threshold=self.delta_threshold)
        
        # Check volume
        stats = footprint.get_stats()
        if stats['total_volume'] < self.volume_threshold:
            return None
        
        # Check if price didn't move much (real absorption)
        # If absorption_price was above/below but price didn't change = absorption
        if imbalance == 'buy':
            # Check if price is near the absorption level (didn't rise significantly)
            if abs(current_price - price_level) / price_level < 0.005:  # 0.5% threshold
                return 'BUY'
        elif imbalance == 'sell':
            # Check if price is near the absorption level (didn't fall significantly)
            if abs(current_price - price_level) / price_level < 0.005:  # 0.5% threshold
                return 'SELL'
        
        return None
    
    def find_absorption_zones(self, df: pd.DataFrame, 
                             footprints: List[KlineFootprint],
                             lookback: int = 5) -> Dict[float, str]:
        """
        Finds absorption zones in the last N candles
        
        Args:
            df: DataFrame with OHLCV data
            footprints: List of KlineFootprint objects
            lookback: Number of candles to analyze
        
        Returns:
            {price: 'BUY' or 'SELL', ...}
        """
        absorption_zones = {}
        
        # Analyze last N candles
        start_idx = max(0, len(df) - lookback)
        
        for i in range(start_idx, len(df)):
            footprint = footprints[i]
            current_price = df['close'].iloc[i]
            
            # Get all price levels in this footprint
            price_levels = footprint.get_price_levels()
            
            for price_level in price_levels:
                absorption_type = self.detect_absorption(
                    footprint, price_level, current_price
                )
                
                if absorption_type:
                    # Store the strongest absorption at each price level
                    if price_level not in absorption_zones:
                        absorption_zones[price_level] = absorption_type
        
        return absorption_zones
    
    def get_absorption_strength(self, footprint: KlineFootprint, 
                               price: float) -> float:
        """Returns absorption strength at a price (0-1)"""
        imbalance = footprint.get_imbalance(price, threshold=self.delta_threshold)
        
        if not imbalance:
            return 0.0
        
        # Get delta percentage (already 0-1 range)
        delta_pct = footprint.get_delta_percentage(price)
        
        # delta_pct is already in 0-1 range, no need to divide by 100
        strength = abs(delta_pct)
        
        # Apply threshold
        if strength < self.delta_threshold:
            return 0.0
        
        return min(1.0, strength)


# ============================================================================
# 5. TRADING STRATEGY
# ============================================================================

class TradingStrategy:
    """Master strategy that generates signals combining SMC + Orderflow"""
    
    def __init__(self, 
                 min_rr: float = 3.0,
                 min_confidence: float = 0.7,
                 delta_threshold: float = 0.65,
                 volume_threshold: float = 100000,
                 active_sessions: List[str] = None,
                 atr_period: int = 14):
        """
        Args:
            min_rr: Minimum Risk/Reward ratio (default 1:3)
            min_confidence: Minimum signal confidence (0-1)
            delta_threshold: Orderflow absorption threshold (0-1)
            volume_threshold: Minimum volume for absorption detection
            active_sessions: List of active sessions to trade
            atr_period: ATR calculation period for dynamic SL/TP
        """
        self.min_rr = min_rr
        self.min_confidence = min_confidence
        
        self.smc_analyzer = SMCIndicator()
        self.orderflow_analyzer = OrderflowAnalyzer(
            delta_threshold=delta_threshold,
            volume_threshold=volume_threshold
        )
        self.session_filter = SessionFilter(active_sessions)
        self.atr_calc = ATRCalculator(period=atr_period)
    
    def analyze(self, df: pd.DataFrame, 
               footprints: List[KlineFootprint]) -> Dict:
        """
        Complete analysis: SMC + Orderflow
        
        Args:
            df: DataFrame with OHLCV
            footprints: List of KlineFootprint per candle
        
        Returns:
            {
                'smc': SMC analysis dict,
                'orderflow': Absorption zones,
                'signals': List[Signal],
                'current_bias': 'bullish'/'bearish'/'neutral',
                'confluence_level': float (0-1),
            }
        """
        # 1. SMC Analysis
        smc_result = self.smc_analyzer.analyze(df)
        
        # 2. Orderflow Analysis
        absorption_zones = self.orderflow_analyzer.find_absorption_zones(
            df, footprints, lookback=5
        )
        
        # 3. Generate signals (confluence)
        signals = self._generate_signals(df, smc_result, absorption_zones, footprints)
        
        # 4. Market bias
        bias = self._determine_bias(smc_result)
        
        # 5. Confluence level
        confluence = self._calculate_confluence(signals)
        
        return {
            'smc': smc_result,
            'orderflow': absorption_zones,
            'signals': signals,
            'current_bias': bias,
            'confluence_level': confluence,
            'last_analysis': df.index[-1],
        }
    
    def _generate_signals(self, df: pd.DataFrame, 
                         smc_result: Dict,
                         absorption_zones: Dict,
                         footprints: List[KlineFootprint]) -> List[Signal]:
        """
        Generates confluence signals: SMC + Orderflow
        
        STRONG ENTRY LONG SIGNAL:
        ‚úì Last BOS = BULLISH
        ‚úì Active bullish FFG (price in the gap)
        ‚úì BUY absorption in the FFG
        ‚úì RR >= 1:3
        ‚Üí Confidence = 0.8-1.0
        
        STRONG ENTRY SHORT SIGNAL:
        ‚úì Last BOS = BEARISH
        ‚úì Active bearish FFG (price in the gap)
        ‚úì SELL absorption in the FFG
        ‚úì RR >= 1:3
        ‚Üí Confidence = 0.8-1.0
        
        WEAK SIGNAL (confidence 0.5-0.7):
        - SMC only without orderflow
        - Orderflow without BOS
        """
        signals = []
        
        current_price = df['close'].iloc[-1]
        current_index = len(df) - 1
        current_time = str(df.index[-1])
        
        # 1. Find last BOS
        last_bos = smc_result.get('last_bos')
        
        # 2. Find active FFGs
        active_ffg = smc_result.get('active_ffg', [])
        
        # 3. Look for absorption in those levels
        for ffg in active_ffg:
            # Is there absorption in the FFG range?
            absorption_in_ffg = self._find_absorption_in_range(
                absorption_zones, ffg.bottom_price, ffg.top_price
            )
            
            if not absorption_in_ffg:
                continue
            
            # Does direction match?
            if ffg.direction == 'bullish' and absorption_in_ffg == 'BUY':
                # LONG signal
                signal = self._create_entry_signal(
                    signal_type='ENTRY_LONG',
                    index=current_index,
                    price=current_price,
                    time=current_time,
                    smc_component='BOS+FFG',
                    orderflow_component='ABSORPTION_BUY',
                    df=df,
                    smc_result=smc_result,
                    ffg=ffg,
                )
                if signal and signal.entry_setup.is_valid_rr(self.min_rr):
                    signals.append(signal)
            
            elif ffg.direction == 'bearish' and absorption_in_ffg == 'SELL':
                # SHORT signal
                signal = self._create_entry_signal(
                    signal_type='ENTRY_SHORT',
                    index=current_index,
                    price=current_price,
                    time=current_time,
                    smc_component='BOS+FFG',
                    orderflow_component='ABSORPTION_SELL',
                    df=df,
                    smc_result=smc_result,
                    ffg=ffg,
                )
                if signal and signal.entry_setup.is_valid_rr(self.min_rr):
                    signals.append(signal)
        
        return signals
    
    def _create_entry_signal(self, signal_type: str,
                            index: int, price: float, time: str,
                            smc_component: str, orderflow_component: str,
                            df: pd.DataFrame, smc_result: Dict,
                            ffg) -> Optional[Signal]:
        """Creates an entry signal with RR setup"""
        
        if signal_type == 'ENTRY_LONG':
            # Entry: at the bullish FFG
            entry_price = ffg.bottom_price
            
            # SL: below the last swing low or below the OB
            last_swing = smc_result['last_swing']
            sl_price = last_swing.price if last_swing and last_swing.swing_type == 'low' else entry_price * 0.99
            
            # TP: at the next swing high or resistance
            next_resistance = self._get_next_resistance(smc_result)
            tp_price = next_resistance if next_resistance else entry_price * 1.05
        
        else:  # ENTRY_SHORT
            # Entry: at the bearish FFG
            entry_price = ffg.top_price
            
            # SL: above the last swing high
            last_swing = smc_result['last_swing']
            sl_price = last_swing.price if last_swing and last_swing.swing_type == 'high' else entry_price * 1.01
            
            # TP: at the next swing low or support
            next_support = self._get_next_support(smc_result)
            tp_price = next_support if next_support else entry_price * 0.95
        
        # Calculate RR
        setup = RiskRewardSetup(
            entry_price=entry_price,
            stop_loss_price=sl_price,
            take_profit_price=tp_price,
            position_size=1.0,  # 1 = 1 lot
        )
        
        if not setup.is_valid_rr(self.min_rr):
            return None
        
        # Confidence based on components
        confidence = 0.75 + (setup.risk_reward_ratio - 3) * 0.05  # Boost if RR > 3
        confidence = min(1.0, confidence)
        
        return Signal(
            signal_type=signal_type,
            index=index,
            price=price,
            time=time,
            confidence=confidence,
            smc_component=smc_component,
            orderflow_component=orderflow_component,
            entry_setup=setup,
            reason=f"{smc_component} + {orderflow_component} @ {entry_price:.2f}, RR={setup.risk_reward_ratio:.1f}"
        )
    
    def _find_absorption_in_range(self, absorption_zones: Dict, 
                                 low: float, high: float) -> Optional[str]:
        """Finds if there's BUY or SELL absorption in a price range"""
        for price, absorption_type in absorption_zones.items():
            if low <= price <= high:
                return absorption_type
        return None
    
    def _get_next_resistance(self, smc_result: Dict) -> Optional[float]:
        """Gets the next resistance level (next swing high)"""
        swings = smc_result.get('swings', [])
        if not swings:
            return None
        
        # Find the first swing high after the current one
        for swing in reversed(swings):
            if swing.swing_type == 'high':
                return swing.price
        return None
    
    def _get_next_support(self, smc_result: Dict) -> Optional[float]:
        """Gets the next support level (next swing low)"""
        swings = smc_result.get('swings', [])
        if not swings:
            return None
        
        for swing in reversed(swings):
            if swing.swing_type == 'low':
                return swing.price
        return None
    
    def _determine_bias(self, smc_result: Dict) -> str:
        """Determines if market is bullish, bearish or neutral"""
        # Based on last BOS
        last_bos = smc_result.get('last_bos')
        if not last_bos:
            return 'neutral'
        
        return 'bullish' if last_bos.direction == 'bullish' else 'bearish'
    
    def _calculate_confluence(self, signals: List[Signal]) -> float:
        """Calculates confluence level (how strong the signals are)"""
        if not signals:
            return 0.0
        
        # Average confidence of all signals
        return sum(s.confidence for s in signals) / len(signals)
    
    def get_current_signal(self, df: pd.DataFrame, 
                          footprints: List[KlineFootprint]) -> Optional[Signal]:
        """Returns the LATEST valid signal (if any)"""
        result = self.analyze(df, footprints)
        signals = result['signals']
        
        if signals:
            # Return the strongest signal (highest confidence)
            return max(signals, key=lambda s: s.confidence)
        return None
    
    def generate_signal(self, df_15m: pd.DataFrame, df_1h: pd.DataFrame, 
                       df_4h: pd.DataFrame, footprints_15m: List[KlineFootprint]) -> Optional[Signal]:
        """Generate multi-timeframe confluence signal with detailed explanation.
        
        Combines:
        1. Session filtering (only trade during active sessions)
        2. 4H bias analysis (market structure direction)
        3. 1H confirmation swing levels (support/resistance)
        4. 15m entry signals (FFG + orderflow absorption)
        5. ATR-based SL/TP sizing (dynamic risk management)
        6. Detailed signal explanation (why this trade)
        
        Args:
            df_15m: 15-minute timeframe DataFrame for entry
            df_1h: 1-hour timeframe DataFrame for confirmation  
            df_4h: 4-hour timeframe DataFrame for bias
            footprints_15m: 15-minute footprint data for orderflow
            
        Returns:
            Signal with detailed explanation or None if no valid signal
        """
        
        # 1. Check active session
        if not self.session_filter.is_active_session(df_15m):
            current_session = self.session_filter.get_current_session(df_15m)
            return None  # Don't trade outside active sessions
        
        # 2. Analyze 4H for bias (market structure direction)
        smc_4h = self.smc_analyzer.analyze(df_4h)
        bias_4h = self._determine_bias(smc_4h)
        
        # Get 4H structural levels
        last_bos_4h = smc_4h.get('last_bos')
        active_ffg_4h = smc_4h.get('active_ffg', [])
        
        if bias_4h == 'neutral':
            return None  # No clear bias, skip trade
        
        # 3. Analyze 1H for confirmation (swing levels)
        smc_1h = self.smc_analyzer.analyze(df_1h)
        swings_1h = smc_1h.get('swings', [])
        
        # Get last swing for confirmation
        last_swing_1h = smc_1h.get('last_swing')
        if not last_swing_1h:
            return None  # No structure to confirm against
        
        # 4. Analyze 15m for entry signals
        smc_15m = self.smc_analyzer.analyze(df_15m)
        
        # Get orderflow absorption zones
        absorption_zones = self.orderflow_analyzer.find_absorption_zones(
            df_15m, footprints_15m, lookback=5
        )
        
        # 5. Check for confluence across timeframes
        current_price = df_15m['close'].iloc[-1]
        
        # Look for active FFG with matching direction
        active_ffg = smc_15m.get('active_ffg', [])
        if not active_ffg:
            return None
        
        # Find FFG that matches 4H bias
        entry_ffg = None
        entry_absorption = None
        
        for ffg in active_ffg:
            if (bias_4h == 'bullish' and ffg.direction == 'bullish'):
                # Check for buy absorption in this FFG
                absorption = self._find_absorption_in_range(
                    absorption_zones, ffg.bottom_price, ffg.top_price
                )
                if absorption == 'BUY':
                    entry_ffg = ffg
                    entry_absorption = absorption
                    break
                    
            elif (bias_4h == 'bearish' and ffg.direction == 'bearish'):
                # Check for sell absorption in this FFG  
                absorption = self._find_absorption_in_range(
                    absorption_zones, ffg.bottom_price, ffg.top_price
                )
                if absorption == 'SELL':
                    entry_ffg = ffg
                    entry_absorption = absorption
                    break
        
        if not entry_ffg:
            return None  # No confluence FFG found
        
        # 6. Calculate ATR-based SL/TP
        atr_15m = self.atr_calc.calculate(df_15m).iloc[-1]
        
        if bias_4h == 'bullish':
            entry_price = entry_ffg.bottom_price
            direction = 'long'
            signal_type = 'ENTRY_LONG'
        else:  # bearish
            entry_price = entry_ffg.top_price
            direction = 'short' 
            signal_type = 'ENTRY_SHORT'
        
        # Create ATR-based setup
        atr_setup = self.atr_calc.get_rr_setup(
            entry_price=entry_price,
            atr=atr_15m,
            direction=direction,
            rr_ratio=self.min_rr / 2.0  # Convert min_rr to full ratio
        )
        
        # Verify ATR setup meets minimum RR
        if not atr_setup.is_valid_rr(self.min_rr):
            return None  # Risk/reward not sufficient
        
        # 7. Calculate confidence based on multi-timeframe factors
        confidence = 0.5  # Base confidence
        
        # Boost for BOS alignment
        if last_bos_4h and last_bos_4h.direction == bias_4h:
            confidence += 0.2
        
        # Boost for 1H swing confirmation
        if last_swing_1h:
            if (direction == 'long' and last_swing_1h.swing_type == 'low'):
                confidence += 0.15
            elif (direction == 'short' and last_swing_1h.swing_type == 'high'):
                confidence += 0.15
        
        # Boost for orderflow absorption strength
        strength = self.orderflow_analyzer.get_absorption_strength(
            footprints_15m[-1], entry_price
        )
        confidence += (strength * 0.15)
        
        # Boost for good RR
        if atr_setup.risk_reward_ratio > self.min_rr:
            confidence += min(0.1, (atr_setup.risk_reward_ratio - self.min_rr) * 0.05)
        
        confidence = min(1.0, confidence)  # Cap at 1.0
        
        # 8. Build detailed explanation
        session_name = self.session_filter.get_current_session(df_15m)
        
        reason_lines = [
            f"üìÖ SESSION: Trading during {session_name}",
            f"üìä 4H BIAS: {bias_4h.upper()} (BOS: {last_bos_4h.price:.2f if last_bos_4h else 'N/A'})",
            f"üîç 1H CONFIRMATION: {last_swing_1h.swing_type} @ {last_swing_1h.price:.2f}",
            f"üéØ 15m ENTRY: {signal_type} at FFG [{entry_ffg.bottom_price:.2f}-{entry_ffg.top_price:.2f}]",
            f"üí∞ ORDERFLOW: {entry_absorption} absorption detected",
            f"üìè RISK: 2√óATR = {atr_15m*2:.2f} ({atr_15m:.2f} ATR)",
            f"üé≤ RR RATIO: {atr_setup.risk_reward_ratio:.1f}:1",
            f"‚úÖ CONFIDENCE: {confidence:.1%}"
        ]
        
        # Check minimum confidence
        if confidence < self.min_confidence:
            return None
        
        # 9. Create final signal
        return Signal(
            signal_type=signal_type,
            index=len(df_15m) - 1,
            price=current_price,
            time=str(df_15m.index[-1]),
            confidence=confidence,
            smc_component=f"{bias_4h.upper()}_BOS",
            orderflow_component=f"ABSORPTION_{entry_absorption}",
            entry_setup=atr_setup,
            reason="\n".join(reason_lines)
        )


# ============================================================================
# 6. MULTI-TIMEFRAME STRATEGY (Optional but powerful)
# ============================================================================

class MultiTimeframeStrategy:
    """Combines analysis across multiple timeframes to confirm signals"""
    
    def __init__(self, timeframes: List[str] = None):
        """
        Args:
            timeframes: ['15m', '1h', '4h', 'd'] (15m = entry, 1h = stop, 4h/d = bias)
        """
        if timeframes is None:
            timeframes = ['15m', '1h', '4h', 'd']
        
        self.timeframes = timeframes
        # Use a single strategy instance with new MTF generation logic
        self.strategy = TradingStrategy()
    
    def analyze(self, df_dict: Dict[str, pd.DataFrame],
               footprints_dict: Dict[str, List[KlineFootprint]]) -> Dict:
        """
        Analyzes multiple timeframes using enhanced confluence logic
        
        Args:
            df_dict: {'15m': df, '1h': df, '4h': df, 'd': df}
            footprints_dict: {'15m': [fp1, fp2], '1h': [...], ...}
        
        Returns:
            {
                'entry_signal': Signal (from 15m, enhanced with MTF analysis),
                'stop_signal': None (deprecated - use generate_signal instead),
                'bias_signal': None (deprecated - integrated into entry_signal),
                'confluence_score': 0-1 (calculated from signal confidence and components),
                'recommendation': 'TAKE_TRADE' / 'SKIP_TRADE' / 'WAIT',
                'session_filter': session status,
                'mtf_analysis': detailed breakdown
            }
        """
        # Use new generate_signal method for proper MTF confluence
        signal = None
        confluence_score = 0.0
        
        # Ensure we have required timeframes
        if '15m' not in df_dict or '4h' not in df_dict:
            # Fall back to old method if missing required timeframes
            return self._legacy_analyze(df_dict, footprints_dict)
        
        # Use enhanced MTF signal generation
        df_15m = df_dict['15m']
        df_1h = df_dict.get('1h', df_dict['15m'])  # Fallback to 15m if no 1h
        df_4h = df_dict['4h']
        footprints_15m = footprints_dict.get('15m', [])
        
        if not footprints_15m:
            return {
                'entry_signal': None,
                'stop_signal': None,
                'bias_signal': None,
                'confluence_score': 0.0,
                'recommendation': 'WAIT',
                'session_filter': self.strategy.session_filter.get_current_session(df_15m),
                'mtf_analysis': {
                    'error': 'No 15m footprint data available'
                }
            }
        
        # Generate MTF signal
        signal = self.strategy.generate_signal(df_15m, df_1h, df_4h, footprints_15m)
        
        if signal:
            confluence_score = signal.confidence
            recommendation = 'TAKE_TRADE' if confluence_score >= 0.7 else 'SKIP_TRADE'
        else:
            recommendation = 'WAIT'
        
        return {
            'entry_signal': signal,
            'stop_signal': None,  # Deprecated - SL/TP now in signal.entry_setup
            'bias_signal': None,  # Deprecated - bias integrated into signal
            'confluence_score': confluence_score,
            'recommendation': recommendation,
            'session_filter': self.strategy.session_filter.get_current_session(df_15m),
            'mtf_analysis': {
                'has_4h_bias': '4h' in df_dict,
                'has_1h_confirmation': '1h' in df_dict,
                'has_orderflow': len(footprints_15m) > 0,
                'signal_details': signal.reason if signal else 'No signal generated'
            }
        }
    
    def _legacy_analyze(self, df_dict: Dict[str, pd.DataFrame],
                       footprints_dict: Dict[str, List[KlineFootprint]]) -> Dict:
        """Backward compatibility method for older analyze() behavior"""
        strategies = {tf: TradingStrategy() for tf in self.timeframes}
        results = {}
        
        # Analyze each timeframe
        for tf in self.timeframes:
            if tf in df_dict and tf in footprints_dict:
                results[tf] = strategies[tf].analyze(
                    df_dict[tf], footprints_dict[tf]
                )
        
        # Get signals from each timeframe
        entry_signal = None
        stop_signal = None
        bias_signal = None
        
        if '15m' in results:
            entry_signal = results['15m'].get('current_signal')
        
        if '1h' in results:
            stop_signal = results['1h'].get('current_signal')
        
        # Use the highest timeframe for bias
        for tf in ['d', '4h', '1h']:
            if tf in results:
                bias_signal = results[tf].get('current_signal')
                break
        
        # Calculate confluence score
        confluence_score = self._calculate_multi_tf_confluence(results)
        
        # Determine recommendation
        recommendation = self._determine_recommendation(
            entry_signal, stop_signal, bias_signal, confluence_score
        )
        
        return {
            'entry_signal': entry_signal,
            'stop_signal': stop_signal,
            'bias_signal': bias_signal,
            'confluence_score': confluence_score,
            'recommendation': recommendation
        }
    
    def _calculate_multi_tf_confluence(self, results: Dict) -> float:
        """Calculates confluence score across multiple timeframes"""
        if not results:
            return 0.0
        
        # Average confluence from all timeframes
        total_confluence = 0.0
        count = 0
        
        for tf, result in results.items():
            total_confluence += result['confluence_level']
            count += 1
        
        if count == 0:
            return 0.0
        
        return total_confluence / count
    
    def _determine_recommendation(self, entry_signal, stop_signal, 
                                 bias_signal, confluence_score) -> str:
        """Determines trade recommendation based on multi-timeframe analysis"""
        
        # If no entry signal, wait
        if not entry_signal:
            return 'WAIT'
        
        # Check if signals align
        signals_align = True
        
        if stop_signal and stop_signal.signal_type != entry_signal.signal_type:
            signals_align = False
        
        if bias_signal and bias_signal.signal_type != entry_signal.signal_type:
            signals_align = False
        
        # Strong confluence and aligned signals
        if confluence_score >= 0.7 and signals_align:
            return 'TAKE_TRADE'
        
        # Moderate confluence
        if confluence_score >= 0.5:
            return 'SKIP_TRADE'
        
        return 'WAIT'
