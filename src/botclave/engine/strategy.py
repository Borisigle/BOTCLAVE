"""
Strategy module that combines SMC indicators with Orderflow data to generate ENTRY/EXIT signals.

This module implements the core trading strategy logic that analyzes market structure
(Smart Money Concepts) and order flow patterns to identify high-probability trading
opportunities with proper risk-reward ratios.
"""

from dataclasses import dataclass
from typing import List, Optional, Dict
import pandas as pd
from botclave.engine.indicators import SMCIndicator
from botclave.engine.footprint import KlineFootprint


# ============================================================================
# 1. SIGNAL DATACLASSES
# ============================================================================

@dataclass
class RiskRewardSetup:
    """Risk/Reward configuration for a trade"""
    entry_price: float
    stop_loss_price: float
    take_profit_price: float
    position_size: float         # As % of capital
    
    @property
    def risk_amount(self) -> float:
        """Risk amount in monetary terms"""
        return abs(self.entry_price - self.stop_loss_price) * self.position_size
    
    @property
    def reward_amount(self) -> float:
        """Potential profit amount"""
        return abs(self.take_profit_price - self.entry_price) * self.position_size
    
    @property
    def risk_reward_ratio(self) -> float:
        """RR = reward / risk"""
        if self.risk_amount == 0:
            return 0.0
        return self.reward_amount / self.risk_amount
    
    def is_valid_rr(self, min_rr: float = 3.0) -> bool:
        """Validate that RR is >= min_rr"""
        return self.risk_reward_ratio >= min_rr


@dataclass
class Signal:
    """Trading signal generated by the strategy"""
    signal_type: str                # 'ENTRY_LONG', 'ENTRY_SHORT', 'EXIT_LONG', 'EXIT_SHORT'
    index: int                      # Index in the DataFrame
    price: float                    # Current price
    time: str                       # Timestamp
    confidence: float               # 0-1, signal strength
    
    # Signal components
    smc_component: str              # 'BOS', 'FFG', 'OB', etc
    orderflow_component: str        # 'ABSORPTION_BUY', 'ABSORPTION_SELL', 'IMBALANCE'
    
    # Setup if it's an entry
    entry_setup: Optional[RiskRewardSetup] = None
    
    # Justification
    reason: str = ""


# ============================================================================
# 2. ABSORPTION DETECTOR (Orderflow Analysis)
# ============================================================================

class OrderflowAnalyzer:
    """Analyzes orderflow/absorption in the footprint to detect smart money activity"""
    
    def __init__(self, delta_threshold: float = 0.65, 
                 volume_threshold: float = 100000):
        """
        Args:
            delta_threshold: % of delta (buy-sell) to consider absorption
            volume_threshold: minimum volume in USD to detect absorption
        """
        self.delta_threshold = delta_threshold
        self.volume_threshold = volume_threshold
    
    def detect_absorption(self, footprint: KlineFootprint, 
                         price_level: float, 
                         current_price: float) -> Optional[str]:
        """
        Detects absorption at a specific price level
        
        BUY absorption:
        - buy_qty >> sell_qty at that level
        - delta > 65% positive
        - Price didn't rise = smart money buying
        
        SELL absorption:
        - sell_qty >> buy_qty at that level
        - delta > 65% negative
        - Price didn't fall = smart money selling
        
        Args:
            footprint: KlineFootprint with trade data
            price_level: Price level to check for absorption
            current_price: Current price
        
        Returns:
            'BUY' (buy absorption), 'SELL' (sell absorption), or None
        """
        # Get imbalance at this price level
        imbalance = footprint.get_imbalance(price_level, threshold=self.delta_threshold)
        
        # Check volume
        stats = footprint.get_stats()
        if stats['total_volume'] < self.volume_threshold:
            return None
        
        # Check if price didn't move much (real absorption)
        # If absorption_price was above/below but price didn't change = absorption
        if imbalance == 'buy':
            # Check if price is near the absorption level (didn't rise significantly)
            if abs(current_price - price_level) / price_level < 0.005:  # 0.5% threshold
                return 'BUY'
        elif imbalance == 'sell':
            # Check if price is near the absorption level (didn't fall significantly)
            if abs(current_price - price_level) / price_level < 0.005:  # 0.5% threshold
                return 'SELL'
        
        return None
    
    def find_absorption_zones(self, df: pd.DataFrame, 
                             footprints: List[KlineFootprint],
                             lookback: int = 5) -> Dict[float, str]:
        """
        Finds absorption zones in the last N candles
        
        Args:
            df: DataFrame with OHLCV data
            footprints: List of KlineFootprint objects
            lookback: Number of candles to analyze
        
        Returns:
            {price: 'BUY' or 'SELL', ...}
        """
        absorption_zones = {}
        
        # Analyze last N candles
        start_idx = max(0, len(df) - lookback)
        
        for i in range(start_idx, len(df)):
            footprint = footprints[i]
            current_price = df['close'].iloc[i]
            
            # Get all price levels in this footprint
            price_levels = footprint.get_price_levels()
            
            for price_level in price_levels:
                absorption_type = self.detect_absorption(
                    footprint, price_level, current_price
                )
                
                if absorption_type:
                    # Store the strongest absorption at each price level
                    if price_level not in absorption_zones:
                        absorption_zones[price_level] = absorption_type
        
        return absorption_zones
    
    def get_absorption_strength(self, footprint: KlineFootprint, 
                               price: float) -> float:
        """Returns absorption strength at a price (0-1)"""
        imbalance = footprint.get_imbalance(price, threshold=self.delta_threshold)
        
        if not imbalance:
            return 0.0
        
        # Get delta percentage (already 0-1 range)
        delta_pct = footprint.get_delta_percentage(price)
        
        # delta_pct is already in 0-1 range, no need to divide by 100
        strength = abs(delta_pct)
        
        # Apply threshold
        if strength < self.delta_threshold:
            return 0.0
        
        return min(1.0, strength)


# ============================================================================
# 3. STRATEGY ENGINE
# ============================================================================

class TradingStrategy:
    """Master strategy that generates signals combining SMC + Orderflow"""
    
    def __init__(self, 
                 min_rr: float = 3.0,
                 min_confidence: float = 0.7,
                 delta_threshold: float = 0.65,
                 volume_threshold: float = 100000):
        """
        Args:
            min_rr: Minimum Risk/Reward ratio (default 1:3)
            min_confidence: Minimum signal confidence (0-1)
        """
        self.min_rr = min_rr
        self.min_confidence = min_confidence
        
        self.smc_analyzer = SMCIndicator()
        self.orderflow_analyzer = OrderflowAnalyzer(
            delta_threshold=delta_threshold,
            volume_threshold=volume_threshold
        )
    
    def analyze(self, df: pd.DataFrame, 
               footprints: List[KlineFootprint]) -> Dict:
        """
        Complete analysis: SMC + Orderflow
        
        Args:
            df: DataFrame with OHLCV
            footprints: List of KlineFootprint per candle
        
        Returns:
            {
                'smc': SMC analysis dict,
                'orderflow': Absorption zones,
                'signals': List[Signal],
                'current_bias': 'bullish'/'bearish'/'neutral',
                'confluence_level': float (0-1),
            }
        """
        # 1. SMC Analysis
        smc_result = self.smc_analyzer.analyze(df)
        
        # 2. Orderflow Analysis
        absorption_zones = self.orderflow_analyzer.find_absorption_zones(
            df, footprints, lookback=5
        )
        
        # 3. Generate signals (confluence)
        signals = self._generate_signals(df, smc_result, absorption_zones, footprints)
        
        # 4. Market bias
        bias = self._determine_bias(smc_result)
        
        # 5. Confluence level
        confluence = self._calculate_confluence(signals)
        
        return {
            'smc': smc_result,
            'orderflow': absorption_zones,
            'signals': signals,
            'current_bias': bias,
            'confluence_level': confluence,
            'last_analysis': df.index[-1],
        }
    
    def _generate_signals(self, df: pd.DataFrame, 
                         smc_result: Dict,
                         absorption_zones: Dict,
                         footprints: List[KlineFootprint]) -> List[Signal]:
        """
        Generates confluence signals: SMC + Orderflow
        
        STRONG ENTRY LONG SIGNAL:
        ✓ Last BOS = BULLISH
        ✓ Active bullish FFG (price in the gap)
        ✓ BUY absorption in the FFG
        ✓ RR >= 1:3
        → Confidence = 0.8-1.0
        
        STRONG ENTRY SHORT SIGNAL:
        ✓ Last BOS = BEARISH
        ✓ Active bearish FFG (price in the gap)
        ✓ SELL absorption in the FFG
        ✓ RR >= 1:3
        → Confidence = 0.8-1.0
        
        WEAK SIGNAL (confidence 0.5-0.7):
        - SMC only without orderflow
        - Orderflow without BOS
        """
        signals = []
        
        current_price = df['close'].iloc[-1]
        current_index = len(df) - 1
        current_time = str(df.index[-1])
        
        # 1. Find last BOS
        last_bos = smc_result.get('last_bos')
        
        # 2. Find active FFGs
        active_ffg = smc_result.get('active_ffg', [])
        
        # 3. Look for absorption in those levels
        for ffg in active_ffg:
            # Is there absorption in the FFG range?
            absorption_in_ffg = self._find_absorption_in_range(
                absorption_zones, ffg.bottom_price, ffg.top_price
            )
            
            if not absorption_in_ffg:
                continue
            
            # Does direction match?
            if ffg.direction == 'bullish' and absorption_in_ffg == 'BUY':
                # LONG signal
                signal = self._create_entry_signal(
                    signal_type='ENTRY_LONG',
                    index=current_index,
                    price=current_price,
                    time=current_time,
                    smc_component='BOS+FFG',
                    orderflow_component='ABSORPTION_BUY',
                    df=df,
                    smc_result=smc_result,
                    ffg=ffg,
                )
                if signal and signal.entry_setup.is_valid_rr(self.min_rr):
                    signals.append(signal)
            
            elif ffg.direction == 'bearish' and absorption_in_ffg == 'SELL':
                # SHORT signal
                signal = self._create_entry_signal(
                    signal_type='ENTRY_SHORT',
                    index=current_index,
                    price=current_price,
                    time=current_time,
                    smc_component='BOS+FFG',
                    orderflow_component='ABSORPTION_SELL',
                    df=df,
                    smc_result=smc_result,
                    ffg=ffg,
                )
                if signal and signal.entry_setup.is_valid_rr(self.min_rr):
                    signals.append(signal)
        
        return signals
    
    def _create_entry_signal(self, signal_type: str,
                            index: int, price: float, time: str,
                            smc_component: str, orderflow_component: str,
                            df: pd.DataFrame, smc_result: Dict,
                            ffg) -> Optional[Signal]:
        """Creates an entry signal with RR setup"""
        
        if signal_type == 'ENTRY_LONG':
            # Entry: at the bullish FFG
            entry_price = ffg.bottom_price
            
            # SL: below the last swing low or below the OB
            last_swing = smc_result['last_swing']
            sl_price = last_swing.price if last_swing and last_swing.swing_type == 'low' else entry_price * 0.99
            
            # TP: at the next swing high or resistance
            next_resistance = self._get_next_resistance(smc_result)
            tp_price = next_resistance if next_resistance else entry_price * 1.05
        
        else:  # ENTRY_SHORT
            # Entry: at the bearish FFG
            entry_price = ffg.top_price
            
            # SL: above the last swing high
            last_swing = smc_result['last_swing']
            sl_price = last_swing.price if last_swing and last_swing.swing_type == 'high' else entry_price * 1.01
            
            # TP: at the next swing low or support
            next_support = self._get_next_support(smc_result)
            tp_price = next_support if next_support else entry_price * 0.95
        
        # Calculate RR
        setup = RiskRewardSetup(
            entry_price=entry_price,
            stop_loss_price=sl_price,
            take_profit_price=tp_price,
            position_size=1.0,  # 1 = 1 lot
        )
        
        if not setup.is_valid_rr(self.min_rr):
            return None
        
        # Confidence based on components
        confidence = 0.75 + (setup.risk_reward_ratio - 3) * 0.05  # Boost if RR > 3
        confidence = min(1.0, confidence)
        
        return Signal(
            signal_type=signal_type,
            index=index,
            price=price,
            time=time,
            confidence=confidence,
            smc_component=smc_component,
            orderflow_component=orderflow_component,
            entry_setup=setup,
            reason=f"{smc_component} + {orderflow_component} @ {entry_price:.2f}, RR={setup.risk_reward_ratio:.1f}"
        )
    
    def _find_absorption_in_range(self, absorption_zones: Dict, 
                                 low: float, high: float) -> Optional[str]:
        """Finds if there's BUY or SELL absorption in a price range"""
        for price, absorption_type in absorption_zones.items():
            if low <= price <= high:
                return absorption_type
        return None
    
    def _get_next_resistance(self, smc_result: Dict) -> Optional[float]:
        """Gets the next resistance level (next swing high)"""
        swings = smc_result.get('swings', [])
        if not swings:
            return None
        
        # Find the first swing high after the current one
        for swing in reversed(swings):
            if swing.swing_type == 'high':
                return swing.price
        return None
    
    def _get_next_support(self, smc_result: Dict) -> Optional[float]:
        """Gets the next support level (next swing low)"""
        swings = smc_result.get('swings', [])
        if not swings:
            return None
        
        for swing in reversed(swings):
            if swing.swing_type == 'low':
                return swing.price
        return None
    
    def _determine_bias(self, smc_result: Dict) -> str:
        """Determines if market is bullish, bearish or neutral"""
        # Based on last BOS
        last_bos = smc_result.get('last_bos')
        if not last_bos:
            return 'neutral'
        
        return 'bullish' if last_bos.direction == 'bullish' else 'bearish'
    
    def _calculate_confluence(self, signals: List[Signal]) -> float:
        """Calculates confluence level (how strong the signals are)"""
        if not signals:
            return 0.0
        
        # Average confidence of all signals
        return sum(s.confidence for s in signals) / len(signals)
    
    def get_current_signal(self, df: pd.DataFrame, 
                          footprints: List[KlineFootprint]) -> Optional[Signal]:
        """Returns the LATEST valid signal (if any)"""
        result = self.analyze(df, footprints)
        signals = result['signals']
        
        if signals:
            # Return the strongest signal (highest confidence)
            return max(signals, key=lambda s: s.confidence)
        return None


# ============================================================================
# 4. MULTI-TIMEFRAME STRATEGY (Optional but powerful)
# ============================================================================

class MultiTimeframeStrategy:
    """Combines analysis across multiple timeframes to confirm signals"""
    
    def __init__(self, timeframes: List[str] = None):
        """
        Args:
            timeframes: ['15m', '1h', '4h', 'd'] (15m = entry, 1h = stop, 4h/d = bias)
        """
        if timeframes is None:
            timeframes = ['15m', '1h', '4h', 'd']
        
        self.timeframes = timeframes
        self.strategies = {tf: TradingStrategy() for tf in timeframes}
    
    def analyze(self, df_dict: Dict[str, pd.DataFrame],
               footprints_dict: Dict[str, List[KlineFootprint]]) -> Dict:
        """
        Analyzes multiple timeframes
        
        Args:
            df_dict: {'15m': df, '1h': df, '4h': df, 'd': df}
            footprints_dict: {'15m': [fp1, fp2], '1h': [...], ...}
        
        Returns:
            {
                'entry_signal': Signal (from 15m),
                'stop_signal': Signal (from 1h),
                'bias_signal': Signal (from 4h/d),
                'confluence_score': 0-1,
                'recommendation': 'TAKE_TRADE' / 'SKIP_TRADE' / 'WAIT'
            }
        """
        results = {}
        
        # Analyze each timeframe
        for tf in self.timeframes:
            if tf in df_dict and tf in footprints_dict:
                results[tf] = self.strategies[tf].analyze(
                    df_dict[tf], footprints_dict[tf]
                )
        
        # Get signals from each timeframe
        entry_signal = None
        stop_signal = None
        bias_signal = None
        
        if '15m' in results:
            entry_signal = results['15m'].get('current_signal')
        
        if '1h' in results:
            stop_signal = results['1h'].get('current_signal')
        
        # Use the highest timeframe for bias
        for tf in ['d', '4h', '1h']:
            if tf in results:
                bias_signal = results[tf].get('current_signal')
                break
        
        # Calculate confluence score
        confluence_score = self._calculate_multi_tf_confluence(results)
        
        # Determine recommendation
        recommendation = self._determine_recommendation(
            entry_signal, stop_signal, bias_signal, confluence_score
        )
        
        return {
            'entry_signal': entry_signal,
            'stop_signal': stop_signal,
            'bias_signal': bias_signal,
            'confluence_score': confluence_score,
            'recommendation': recommendation
        }
    
    def _calculate_multi_tf_confluence(self, results: Dict) -> float:
        """Calculates confluence score across multiple timeframes"""
        if not results:
            return 0.0
        
        # Average confluence from all timeframes
        total_confluence = 0.0
        count = 0
        
        for tf, result in results.items():
            total_confluence += result['confluence_level']
            count += 1
        
        if count == 0:
            return 0.0
        
        return total_confluence / count
    
    def _determine_recommendation(self, entry_signal, stop_signal, 
                                 bias_signal, confluence_score) -> str:
        """Determines trade recommendation based on multi-timeframe analysis"""
        
        # If no entry signal, wait
        if not entry_signal:
            return 'WAIT'
        
        # Check if signals align
        signals_align = True
        
        if stop_signal and stop_signal.signal_type != entry_signal.signal_type:
            signals_align = False
        
        if bias_signal and bias_signal.signal_type != entry_signal.signal_type:
            signals_align = False
        
        # Strong confluence and aligned signals
        if confluence_score >= 0.7 and signals_align:
            return 'TAKE_TRADE'
        
        # Moderate confluence
        if confluence_score >= 0.5:
            return 'SKIP_TRADE'
        
        return 'WAIT'
